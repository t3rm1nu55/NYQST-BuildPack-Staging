# P0-002 â€” Fix run_event sequence race under concurrent writers

- Type: **task**
- Milestone: `M0-P0`
- Repo alignment: **missing**
- Labels: `priority:P0`, `backend`, `runs`, `db`
- Depends on: `EPIC-P0`

## Problem

`RunRepository.create_run_event()` reads the current max sequence and then writes `sequence+1`. Under concurrency this can create duplicates/out-of-order sequences, breaking UI timelines and downstream logic.

## Proposed solution

Ensure run_event sequencing is monotonic and concurrency-safe.

Recommended implementation:
- Add a DB-side sequence via `run_events.sequence` populated from `nextval()` scoped by `run_id`, or
- Use a `SELECT ... FOR UPDATE` lock on the parent `runs` row and store `last_sequence` on `runs`, or
- Use a unique constraint on `(run_id, sequence)` plus retry loop.

Also ensure LISTEN/NOTIFY payloads preserve order or include sequence to allow client ordering.

## Repo touchpoints

- `src/intelli/repositories/runs.py`
- `src/intelli/db/models/runs.py`
- `migrations/versions/*`

## Spec / reference pointers

- reference/NYQST_Platform_Production_Intelligence_Build_Guide_v5.md (P0-2)

## Acceptance criteria

- Concurrent creation of N run events results in strictly increasing, gap-free sequences per run.
- UI timeline ordering is stable even under high event volume.
- Constraint prevents duplicates and code retries gracefully.

## Test plan

- Unit test with concurrent tasks/threads creating events; assert unique & ordered.
- Integration test with Postgres: verify unique constraint and retry behaviour.
